# Digital Twin Development

_Purpose:_
The digital twin will accurately replicate the real-world 3D concrete printing process, including physics, external forces, and all other relevant components. This virtual environment will be used to validate prints, detect issues, and understand their sources before proceeding to actual physical printing.

---

<details>

<summary>Step 1</summary>

### **1. Robot Model Creation and Launch in Gazebo**

_Objective:
To create a virtual representation of the ABB IRB 1660 robot and launch it in the Gazebo simulation environment._

**Steps:**

1. **ROS 2 Workspace Setup:**
   - Create a dedicated ROS 2 workspace for the project (e.g., `ros2_irb1660`).
   - Ensure all necessary dependencies (ROS 2 Humble, Gazebo) are installed.
   - Initialize the workspace, create a `src` directory, and clone any relevant repositories.

2. **URDF File Creation:**
   - Write the URDF (Unified Robot Description Format) file for the ABB IRB 1660.
     - **Components to Include:**
       - Links and joints corresponding to the physical components of the robot.
       - Definition of the robot’s kinematic chain.
       - Inclusion of physical properties like mass, inertia, and joint limits.
     - **Testing:**
       - Visualize the URDF in Rviz to ensure the model is correctly defined.
       - Debug and correct any issues with link orientations, joint connections, etc.

3. **Launch Files:**
   - Create ROS 2 launch files to spawn the robot in Gazebo.
     - **Files to Create:**
       - `spawn_robot_gazebo.launch.py` to load the robot model into Gazebo.
       - `display.launch.py` for visualizing the robot in Rviz, if necessary.
     - **Testing:**
       - Launch the robot in Gazebo and verify its presence, orientation, and scale.

4. **Building the Network of Files:**
   - Organize the workspace to include URDF files, meshes (if using detailed 3D models), configuration files, and launch files.
   - Ensure all paths in `CMakeLists.txt` and `package.xml` are correct.
   - Build and source the workspace, resolving any dependencies or errors.
</details>

---

<details>

<summary>Step 2</summary>

### **2. Making the Robot Moveable**

_Objective:
To enable movement of the ABB IRB 1660 model within Gazebo, allowing for testing of motion and control algorithms._

**Steps:**

1. **Determine Control Strategy:**
   - **Options:**
     - Use a joint position controller to move the robot’s joints directly.
     - Implement a more complex control strategy involving velocity or effort controllers.
   - **Considerations:**
     - If simple motion is required initially, start with a joint position controller.
     - For more dynamic and realistic movement, consider implementing velocity controllers.

2. **Set Up Controllers:**
   - **Steps:**
     - Define the necessary controllers in a YAML configuration file.
     - Include `JointStateController` for feedback on the robot’s joint states.
     - Add specific controllers like `JointTrajectoryController` for planned motion.
   - **Launch Files:**
     - Update the Gazebo launch files to include controller initialization.
     - Load the controllers using a `controller_spawner` node.

3. **Testing Movement:**
   - **Tools:**
     - Use ROS 2 command-line tools or a custom node to send joint commands.
     - Visualize the robot’s movement in Gazebo and verify that it follows the commands accurately.
   - **Debugging:**
     - Address any issues with controller configuration, such as incorrect PID settings or unresponsive joints.

</details>

---

<details>

<summary>Step 3</summary>

### **3. Integrating Forward and Inverse Kinematics**

_Objective:
To implement both forward and inverse kinematics, allowing manual control of the robot’s joints and automated path-following based on a desired end-effector position._

**Steps:**

1. **Forward Kinematics Implementation:**
   - **Purpose:**
     - Enable manual control over the robot’s joints, providing flexibility in positioning.
   - **Tools:**
     - Implement a kinematics library or utilize existing ROS packages like `moveit2`.
   - **Integration:**
     - Develop or adapt a node to accept joint commands and compute the corresponding end-effector position.
     - Test in simulation to ensure accurate positioning.

2. **Inverse Kinematics (IK) Setup:**
   - **Purpose:**
     - Allow the robot to follow a predefined path or reach a specific point in space.
   - **Tools:**
     - Use an IK solver, potentially from `moveit2` or a custom implementation.
   - **Integration:**
     - Create or modify nodes to take Cartesian coordinates as input and solve for joint angles.
     - Test by defining a path in space and verifying that the robot can follow it accurately.

3. **Simulating a Print Path:**
   - **Objective:**
     - Load a G-code file or another form of path instruction into the digital twin.
   - **Integration:**
     - Develop a script or node that translates the path data into joint commands using IK.
     - Test the robot’s ability to follow complex paths in simulation, adjusting as necessary for smooth motion.

</details>

---

<details>

<summary>Step 4</summary>

### **4. Virtual Environment Setup**

_Objective:
To set up the digital environment, including all necessary lab components, within Gazebo._

**Steps:**

1. **Modeling Lab Components:**
   - **Components:**
     - Mixer with sensors, printing table, data collection tools (e.g., camera), and any other relevant equipment.
   - **URDF/SDFormat Files:**
     - Create or obtain URDF or SDFormat files for each component, ensuring they accurately reflect real-world functionality.
   - **Integration:**
     - Add these components to the Gazebo simulation, ensuring proper placement and interaction with the robot.

2. **Functionality Simulation:**
   - **Objective:**
     - Mimic the functionality of each component in the virtual environment.
   - **Tools:**
     - Use Gazebo plugins or custom ROS nodes to simulate sensor readings, actuator movements, etc.
   - **Testing:**
     - Run simulations to ensure that all components interact correctly and provide realistic feedback.

</details>

---

<details>

<summary>Step 5</summary>

### **5. Fluid Simulation for Concrete**

_Objective:
To simulate the behavior of the concrete being printed, accounting for factors like viscosity, flow rate, and deposition accuracy._

**Steps:**

1. **Determine Simulation Requirements:**
   - **Parameters:**
     - Identify key parameters like viscosity, flow rate, and curing time.
   - **Tools:**
     - Explore available fluid simulation tools that can integrate with Gazebo (e.g., custom plugins, third-party libraries).

2. **Implement Fluid Simulation:**
   - **Integration:**
     - Develop or integrate a fluid simulation model that mimics the behavior of concrete.
   - **Testing:**
     - Simulate a basic printing scenario and adjust the fluid model to match expected real-world behavior.

3. **Optimization and Refinement:**
   - **Objective:**
     - Fine-tune the simulation to ensure that it accurately reflects the printing process.
   - **Testing:**
     - Run multiple simulations with different parameters to validate the model.

</details>

---

<details>

<summary>Step 6</summary>

### **6. Verification and Testing**

_Objective:
To test the fully developed digital twin by running simulations that replicate real-world printing scenarios._

**Steps:**

1. **Scenario Definition:**
   - **Scenarios:**
     - Define various test scenarios, including different print designs, materials, and environmental conditions.
   - **Execution:**
     - Run simulations and monitor the robot’s performance, including print accuracy and error detection.

2. **Validation:**
   - **Comparison:**
     - Compare simulation results with expected outcomes and real-world data.
   - **Adjustment:**
     - Make necessary adjustments to the simulation models, control algorithms, and kinematics to improve accuracy.

3. **Final Testing:**
   - **Objective:**
     - Conduct a final round of testing to ensure that the digital twin is ready for use in validating real-world prints.
   - **Outcome:**
     - Confirm that the digital twin can reliably predict and mitigate issues before physical printing begins.

</details>
