# Digital Twin Development

_Purpose:_
The digital twin will accurately replicate the real-world 3D concrete printing process, including physics, external forces, and all other relevant components. This virtual environment will be used to validate prints, detect issues, and understand their sources before proceeding to actual physical printing.

---

<details>

<summary>Step 1</summary>

### **1. Robot Model Creation and Launch in Gazebo**

**Objective:**
To create a virtual representation of the ABB IRB 1660 robot and launch it in the Gazebo simulation environment. This is a crucial step in developing the digital twin, as it provides the foundational model that will be used for all subsequent simulation, control, and analysis tasks.

**Steps:**

1. **ROS 2 Workspace Setup:**
   - **Why:** The ROS 2 workspace is the environment where all the files, nodes, and configurations related to the digital twin will reside. Setting up a dedicated workspace ensures that all components of the project are organized, modular, and easily accessible for development and testing.
   - **How:**
     - Create a dedicated ROS 2 workspace for the project (e.g., `ros2_irb1660`).
     - Ensure that all necessary dependencies, such as ROS 2 Humble and Gazebo, are installed and properly configured.
     - Initialize the workspace, create a `src` directory where all source code and files will be stored, and clone any relevant repositories that may contain example code or necessary libraries.

2. **URDF File Creation:**
   - **Why:** The URDF (Unified Robot Description Format) file is essential for defining the physical and kinematic structure of the ABB IRB 1660 within the simulation. It describes the robot's geometry, joint connections, and physical properties, making it possible to simulate realistic motion and interactions in the digital environment.
   - **How:**
     - Write the URDF file, specifying the robot's links (individual parts) and joints (connections between parts) to mirror the physical robot.
     - Include details such as the kinematic chain (the sequence of joints and links), which is crucial for calculating the robot's movements and simulating its behavior accurately.
     - Incorporate physical properties like mass, inertia, and joint limits to ensure that the simulation reflects real-world dynamics, allowing for more accurate testing and validation of the robot's performance.
     - **Testing:**
       - Visualize the URDF in Rviz, a ROS tool for 3D visualization, to ensure that the model is correctly defined, with all parts and connections in place.
       - Debug and correct any issues related to link orientations, joint connections, or physical properties to prevent errors in the simulation.

3. **Launch Files:**
   - **Why:** Launch files are essential for automating the process of starting up the simulation with all necessary components. They ensure that the robot model is correctly loaded into Gazebo and can be easily visualized and tested.
   - **How:**
     - Create a `spawn_robot_gazebo.launch.py` file to load the robot model into Gazebo, specifying the necessary parameters such as the URDF file location and initial conditions.
     - If visualization in Rviz is needed (for example, to monitor the robot’s joint states or debug issues), create a `display.launch.py` file.
     - **Testing:**
       - Launch the robot in Gazebo and verify that it appears correctly within the simulated environment. Check for correct orientation, scale, and overall appearance.
       - Use Rviz, if needed, to further inspect the robot model and ensure that all visual aspects are as expected.

4. **Building the Network of Files:**
   - **Why:** Proper organization and configuration of the workspace are critical for the smooth operation of the simulation and future development. Ensuring that all files are correctly set up prevents errors during compilation and runtime, facilitating a more efficient development process.
   - **How:**
     - Organize the workspace to include all relevant URDF files, 3D meshes (if using detailed models), configuration files, and launch files. This structure allows for easy access and modification as the project evolves.
     - Verify that all paths in `CMakeLists.txt` (which controls the build process) and `package.xml` (which defines dependencies) are correct. This step ensures that the ROS 2 build system can locate and compile all necessary files without issues.
     - Build and source the workspace to resolve any dependencies or errors, making sure that the project is ready for simulation. This process is crucial for integrating all components and ensuring that they work together as intended.

</details>

---

<details>

<summary>Step 2</summary>

### **2. Making the Robot Moveable**

**Objective:**
To enable movement of the ABB IRB 1660 model within Gazebo, allowing for testing of motion and control algorithms. This step is crucial for simulating the robot's behavior under various conditions, which is essential for validating the digital twin's accuracy and preparing for real-world operations. The controller will mimic the real-life ABB robot controller, allowing the robot to be manually moved or to follow a path specified in an uploaded file.

**Steps:**

1. **Determine Control Strategy:**
   - **Why:** Choosing the appropriate control strategy is essential for simulating the robot’s movement realistically and efficiently. The control strategy determines how the robot’s joints will be actuated and how motion will be coordinated, impacting the accuracy and realism of the simulation.
   - **Options:**
     - **Joint Position Controller:** This is the simplest option and is ideal for initial testing and basic movement. It allows for direct control of each joint's position, making it easier to validate basic kinematics and ensure that the robot responds correctly to commands.
     - **Velocity or Effort Controllers:** These provide a more dynamic and realistic simulation by controlling the speed or force applied to each joint. These controllers are closer to how real-world robots operate and are better suited for complex motion tasks, where the robot’s interaction with its environment needs to be accurately simulated.
   - **Considerations:**
     - For initial testing and simple movement, start with a joint position controller to verify basic functionality.
     - For simulating real-world operations, where the robot needs to follow complex paths automatically, a combination of controllers may be used. This includes both manual control (akin to the "teach mode" in the real robot) and automated control for following preloaded paths.

2. **Set Up Controllers:**
   - **Why:** Controllers are the bridge between the commands given to the robot and the actual motion that occurs. Properly setting up controllers ensures that the robot responds accurately to commands, whether they are simple joint positions or complex trajectories. In this case, the setup must accommodate both manual control and automated path-following, mimicking the real ABB controller’s functionality.
   - **Steps:**
     - **Define Controllers in YAML:** Controllers are typically configured in a YAML file, where you specify parameters like joint names, control types, and PID settings. This configuration is crucial for tuning the robot’s response to match real-world behavior.
     - **Include JointStateController:** This controller is essential for providing feedback on the robot’s current joint states, such as positions, velocities, and efforts. It allows for monitoring and adjusting the robot’s movements during simulation.
     - **Add Specific Controllers:**
       - **Manual Control Mode:** Set up a controller that allows for manual joint manipulation, mimicking the “teach mode” of the real robot. This can be done through a simple joint position controller or a more sophisticated interface that allows operators to guide the robot by hand or through a joystick.
       - **Automated Path-Following:** Set up a `JointTrajectoryController` that allows the robot to follow a predefined path. This is where the uploaded file (similar to a G-code or other path specification) will dictate the robot's movements automatically, just as in the real-world scenario.
   - **Launch Files:**
     - **Update Gazebo Launch Files:** Modify the existing Gazebo launch files to initialize the controllers when the simulation starts. This ensures that the robot is ready to move, whether in manual mode or following an automated path.
     - **Use Controller Spawner:** Utilize the `controller_spawner` node to load the controllers during the simulation. This node takes care of initializing and managing the controllers, ensuring they are correctly integrated into the simulation.

3. **Testing Movement:**
   - **Why:** Testing the robot’s movement is essential to ensure that the controllers are functioning correctly and that the robot moves as expected. This step verifies that the simulation accurately reflects the robot’s physical behavior and identifies any issues that need to be addressed.
   - **Tools:**
     - **Manual Control Testing:** Use ROS 2 command-line tools or a custom node to manually control the robot’s joints, simulating the "teach mode" operation. This allows for testing of the robot’s manual movement capabilities and ensuring that operators can guide the robot accurately.
     - **Automated Path Testing:** Upload a path file to the simulation and use the `JointTrajectoryController` to test the robot’s ability to follow the path automatically. This step is crucial for validating the automated control aspect, ensuring that the robot can perform complex tasks without manual intervention.
     - **Visualize in Gazebo:** Watch the robot’s movement in Gazebo to ensure that it follows the commands accurately. This visual feedback is critical for identifying any discrepancies between the expected and actual behavior.
   - **Debugging:**
     - **PID Tuning:** If the robot’s movement is sluggish, oscillatory, or unstable, adjust the PID settings in the controller configuration. Proper tuning is essential for achieving smooth and responsive motion.
     - **Unresponsive Joints:** If certain joints do not move as expected, check the controller configuration, ensure the correct joints are specified, and verify that the controller spawner is correctly initializing all controllers.
     - **Simulation Issues:** If the robot behaves erratically in the simulation, consider adjusting the simulation parameters, such as physics engine settings, to ensure stability and realism.

</details>

---

<details>

<summary>Step 3</summary>

### **3. Integrating Forward and Inverse Kinematics**

_Objective:
To implement both forward and inverse kinematics, allowing manual control of the robot’s joints and automated path-following based on a desired end-effector position._

**Steps:**

1. **Forward Kinematics Implementation:**
   - **Purpose:**
     - Enable manual control over the robot’s joints, providing flexibility in positioning.
   - **Tools:**
     - Implement a kinematics library or utilize existing ROS packages like `moveit2`.
   - **Integration:**
     - Develop or adapt a node to accept joint commands and compute the corresponding end-effector position.
     - Test in simulation to ensure accurate positioning.

2. **Inverse Kinematics (IK) Setup:**
   - **Purpose:**
     - Allow the robot to follow a predefined path or reach a specific point in space.
   - **Tools:**
     - Use an IK solver, potentially from `moveit2` or a custom implementation.
   - **Integration:**
     - Create or modify nodes to take Cartesian coordinates as input and solve for joint angles.
     - Test by defining a path in space and verifying that the robot can follow it accurately.

3. **Simulating a Print Path:**
   - **Objective:**
     - Load a G-code file or another form of path instruction into the digital twin.
   - **Integration:**
     - Develop a script or node that translates the path data into joint commands using IK.
     - Test the robot’s ability to follow complex paths in simulation, adjusting as necessary for smooth motion.

</details>

---

<details>

<summary>Step 4</summary>

### **4. Virtual Environment Setup**

_Objective:
To set up the digital environment, including all necessary lab components, within Gazebo._

**Steps:**

1. **Modeling Lab Components:**
   - **Components:**
     - Mixer with sensors, printing table, data collection tools (e.g., camera), and any other relevant equipment.
   - **URDF/SDFormat Files:**
     - Create or obtain URDF or SDFormat files for each component, ensuring they accurately reflect real-world functionality.
   - **Integration:**
     - Add these components to the Gazebo simulation, ensuring proper placement and interaction with the robot.

2. **Functionality Simulation:**
   - **Objective:**
     - Mimic the functionality of each component in the virtual environment.
   - **Tools:**
     - Use Gazebo plugins or custom ROS nodes to simulate sensor readings, actuator movements, etc.
   - **Testing:**
     - Run simulations to ensure that all components interact correctly and provide realistic feedback.

</details>

---

<details>

<summary>Step 5</summary>

### **5. Fluid Simulation for Concrete**

_Objective:
To simulate the behavior of the concrete being printed, accounting for factors like viscosity, flow rate, and deposition accuracy._

**Steps:**

1. **Determine Simulation Requirements:**
   - **Parameters:**
     - Identify key parameters like viscosity, flow rate, and curing time.
   - **Tools:**
     - Explore available fluid simulation tools that can integrate with Gazebo (e.g., custom plugins, third-party libraries).

2. **Implement Fluid Simulation:**
   - **Integration:**
     - Develop or integrate a fluid simulation model that mimics the behavior of concrete.
   - **Testing:**
     - Simulate a basic printing scenario and adjust the fluid model to match expected real-world behavior.

3. **Optimization and Refinement:**
   - **Objective:**
     - Fine-tune the simulation to ensure that it accurately reflects the printing process.
   - **Testing:**
     - Run multiple simulations with different parameters to validate the model.

</details>

---

<details>

<summary>Step 6</summary>

### **6. Verification and Testing**

_Objective:
To test the fully developed digital twin by running simulations that replicate real-world printing scenarios._

**Steps:**

1. **Scenario Definition:**
   - **Scenarios:**
     - Define various test scenarios, including different print designs, materials, and environmental conditions.
   - **Execution:**
     - Run simulations and monitor the robot’s performance, including print accuracy and error detection.

2. **Validation:**
   - **Comparison:**
     - Compare simulation results with expected outcomes and real-world data.
   - **Adjustment:**
     - Make necessary adjustments to the simulation models, control algorithms, and kinematics to improve accuracy.

3. **Final Testing:**
   - **Objective:**
     - Conduct a final round of testing to ensure that the digital twin is ready for use in validating real-world prints.
   - **Outcome:**
     - Confirm that the digital twin can reliably predict and mitigate issues before physical printing begins.

</details>
